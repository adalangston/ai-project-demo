# -*- coding: utf-8 -*-
"""langston_ada_prediction_ger.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mUB00GsPRpyNdIm3qXpRI-8DGWaE_MYk
"""

import torch
import torch.nn as nn


lr = 0.1

'''no = torch.tensor(0)
yes = torch.tensor(1)'''

# set up class

class Germ_def_art(nn.Module):
  def __init__(self):
    super(Germ_def_art, self).__init__()
    self.layer = nn.Linear(9, 6,bias=False)

  def forward(self, inp):
    return torch.unsqueeze(self.layer(inp),0)

net = Germ_def_art()

criterion = nn.CrossEntropyLoss()
optimiser = torch.optim.Adam(net.parameters(),lr=lr)

# set up input vectors

number = ['singular', 'plural']

gender = ['masculine', 'feminine', 'neuter']

_case = ['nominative', 'genitive', 'dative', 'accusative']

number_vec = {}
for i, n in enumerate(number):
  number_vec[n] = torch.zeros((2), requires_grad=False)
  number_vec[n][i] = 1

gender_vec = {}
for i, g in enumerate(gender):
  gender_vec[g] = torch.zeros((3), requires_grad=False)
  gender_vec[g][i] = 1

case_vec = {}
for i, c in enumerate(_case):
  case_vec[c] = torch.zeros((4), requires_grad=False)
  case_vec[c][i] = 1


# loop network

for epoch in range(100):
  all_correct = True
  ep_loss = 0
  for i, n in enumerate(number):
    for g in gender:
      for c in _case:

        input_vec = torch.cat((number_vec[n], gender_vec[g], case_vec[c]), axis=0)

        # conditionals
        # encoding: der = 0, die = 1, das = 2, dem = 3, den = 4, des = 5
        if n == 'plural':
          if c == 'dative':
            target = torch.unsqueeze(torch.tensor(4), 0)
          elif c == 'genitive':
            target = torch.unsqueeze(torch.tensor(0), 0)
          else:
            target = torch.unsqueeze(torch.tensor(1), 0)


        elif g == 'feminine':
          if c == 'accusative' or c == 'nominative':
            target = torch.unsqueeze(torch.tensor(1), 0)
          else:
            target = torch.unsqueeze(torch.tensor(0), 0)


        elif g == 'neuter':
          if c == 'accusative' or c == 'nominative':
            target = torch.unsqueeze(torch.tensor(2), 0)
          elif c == 'genitive':
            target = torch.unsqueeze(torch.tensor(5), 0)
          else:
            target = torch.unsqueeze(torch.tensor(3), 0)


        else:
          if c == 'accusative':
            target = torch.unsqueeze(torch.tensor(4), 0)
          elif c == 'genitive':
            target = torch.unsqueeze(torch.tensor(5), 0)
          elif c == 'dative':
            target = torch.unsqueeze(torch.tensor(3), 0)
          else:
            target = torch.unsqueeze(torch.tensor(0), 0)

        pred = net(input_vec)

        target = target.long()
        loss = criterion(pred, target)
        ep_loss += loss.detach()
        loss.backward()
        optimiser.step()
        optimiser.zero_grad()

        with torch.no_grad():
          pred_argmax = torch.argmax(pred, axis = 1)
          print(n, g, c, target.item(), pred_argmax.item())

          if pred_argmax.item() != target.item():
            all_correct = False

  print(ep_loss.item())

  if all_correct:
    print("All correct after", epoch, "iterations")
    break